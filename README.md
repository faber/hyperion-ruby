Hyperion [![Build Status](https://secure.travis-ci.org/mylesmegyesi/hyperion-ruby.png)](http://travis-ci.org/mylesmegyesi/hyperion-ruby)
=============

<em>1 API, multiple database backends.</em>

Hyperion provides you with a simple API for data persistence allowing you to delay the choice of database without delaying your development.

There are a few guiding principles for Hyperion.

 1. key/value store.  All Hyperion implementations, even for relational databases, conform to the simple key/value store API.
 2. values are maps.  Every 'value' the goes in or out of a Hyperion datastore is map, or a defrecord when using defentity.
 3. :key and :kind.  Every 'value' must have a :kind entry; a short string like "user" or "product".  Persisted 'value's will have a :key entry; strings generated by the datastore.
 4. Search with data.  All searches are described by data.  See find-by-kind below.

Hyperion Implementations:

 * [memory](https://github.com/mylesmegyesi/hyperion-ruby/blob/master/api/lib/hyperion/memory.rb) - an in-memory datastore, ideal for testing, included in hyperion-api.jar
 * [mysql](https://github.com/mylesmegyesi/hyperion-ruby/tree/master/mysql) - [MySQL](http://www.mysql.com/)
 * [postgres](https://github.com/mylesmegyesi/hyperion-ruby/tree/master/postgres) - [PostgreSQL](http://www.postgresql.org/)
 * [sqlite](https://github.com/mylesmegyesi/hyperion-ruby/tree/master/sqlite) - [SQLite](http://www.sqlite.org/)

## Installation

  gem 'hyperion-<impl here>'

## Usage

### Instantiating datastores

Hyperion::API provides a convenient factory function for instantiating any datastore implementation

    require 'hyperion/api'
    Hyperion::API.new_datastore(:memory)
    Hyperion::API.new_datastore(:mysql)
    Hyperion::API.new_datastore(:postgres, options)
    Hyperion::API.new_datastore(:sqlite, options)

This will require the file "hyperion/<impl>" and instantiate the class Hyperion::<impl camelcased>

Each implementation must accept a hash of options in their initializer

  module Hyperion
    class Memory
      def initialize(opts={})
      end
    end
  end

### Installing a datastore

  # with brute force
  Hyperion::API.datastore = Hyperion::API.new_datastore(:postgres, options)
  # with elegance
  Hyperion::API.with_datastore(:postgres, options)

If you can bind the datastore once at high level in your application, that's ideal.  Otherwise use the brute force technique.
