Hyperion [![Build Status](https://secure.travis-ci.org/mylesmegyesi/hyperion-ruby.png)](http://travis-ci.org/mylesmegyesi/hyperion-ruby)
=============

<em>1 API, multiple database backends.</em>

Hyperion provides you with a simple API for data persistence allowing you to delay the choice of database without delaying your development.

There are a few guiding principles for Hyperion.

 1. key/value store.  All Hyperion implementations, even for relational databases, conform to the simple key/value store API.
 2. values are maps.  Every 'value' the goes in or out of a Hyperion datastore is a hash.
 3. :key and :kind.  Every 'value' must have a :kind entry; a short string like "user" or "product".  Persisted 'value's will have a :key entry; strings generated by the datastore.
 4. Search with data.  All searches are described by data.  See find_by_kind below.

Hyperion Implementations:

 * [memory](https://github.com/mylesmegyesi/hyperion-ruby/blob/master/api/lib/hyperion/memory.rb) - an in-memory datastore, ideal for testing, included in the hyperion-api gem
 * [mysql](https://github.com/mylesmegyesi/hyperion-ruby/tree/master/mysql) - [MySQL](http://www.mysql.com/)
 * [postgres](https://github.com/mylesmegyesi/hyperion-ruby/tree/master/postgres) - [PostgreSQL](http://www.postgresql.org/)
 * [sqlite](https://github.com/mylesmegyesi/hyperion-ruby/tree/master/sqlite) - [SQLite](http://www.sqlite.org/)

## Installation

To use just the in-memory datastore...

``` ruby
gem 'hyperion-api'
```

To use a specific implementation...

``` ruby
gem 'hyperion-postgres'
# or
gem 'hyperion-mysql'
# or
gem 'hyperion-sqlite'
```

## Usage

### Instantiating datastores

Hyperion provides a convenient factory function for instantiating any datastore implementation

``` ruby
require 'hyperion'
Hyperion.new_datastore(:memory)
Hyperion.new_datastore(:mysql)
Hyperion.new_datastore(:postgres, options)
Hyperion.new_datastore(:sqlite, options)
```

This will require the file "hyperion/\<impl\>" and instantiate the class Hyperion::\<impl camelcased\>

Each implementation must accept a hash of options in it's initializer

``` ruby
module Hyperion
  class Memory
    def initialize(opts={})
    end
  end
end
```

### Installing a datastore

#### With elegence

This installs the datastore thread locally, and only within the given block.

``` ruby
# datastore not installed
Hyperion.with_datastore(:postgres, options) do
  # datastore is installed
  # some persistence code here
end
# datastore not installed
```

This method is useful for applications that have control of the main thread, such as webapps. The call to with_datastore can be placed inside of a middleware, such that the datastore is installed at the beginning of the request and uninstalled after the request. For example, this is a Rack middleware which instantiates a postgres datastore, opens a pooled connection, starts a transaction and calls the next middleware.

``` ruby
require 'hyperion'
require 'hyperion/sql'

class DatastoreMiddleware

  def initialize(app)
    @app = app
  end

  def call(env)
    connection_url = 'postgres://cspvswmv:bwTTUFRBRgnb@ec2-23-23-234-187.compute-1.amazonaws.com:5432/d1uh0jkh0n8j3l'
    Hyperion.with_datastore(:postgres, :connection_url => connection_url) do
      Hyperion::Sql.with_connection(connection_url) do
        Hyperion::Sql.transaction do
          @app.call(env)
        end
      end
    end
  end
end
```

Each of these calls could, of course, be their own separate middlewares.

#### With brute force

This installs the datastore across all threads.

``` ruby
Hyperion.datastore = Hyperion.new_datastore(:postgres, options)
```

To uninstall

``` ruby
Hyperion.datastore = nil
```

This method is useful for when you do not have control of the main thread, such as desktop GUI applications.
If you can bind the datastore once at high level in your application, that's ideal.  Otherwise use the brute force technique.

### Saving a value:

    Hyperion.save({:kind => :foo})
    => {:kind=>"foo", :key=>"<generated key>"}
    Hyperion.save({:kind => :foo}, :value => :bar)
    => {:kind=>"foo", :value=>:bar, :key=>"<generated key>"}

### Updating a value:

    record = Hyperion.save({:kind => :foo})
    record[:name] = 'John'
    Hyperion.save(record)
    => {:kind=>"foo", :name=>'John', :key=>"<generated key>"}

### Loading a value:

    find_by_kind(:dog) # returns all records with :kind of \"dog\"
    find_by_kind(:dog, :filters => [[:name, '=', "Fido"]]) # returns all dogs whos name is Fido
    find_by_kind(:dog, :filters => [[:age, '>', 2], [:age, '<', 5]]) # returns all dogs between the age of 2 and 5 (exclusive)
    find_by_kind(:dog, :sorts => [[:name, :asc]]) # returns all dogs in alphebetical order of their name
    find_by_kind(:dog, :sorts => [[:age, :desc], [:name, :asc]]) # returns all dogs ordered from oldest to youngest, and gos of the same age ordered by name
    find_by_kind(:dog, :limit => 10) # returns upto 10 dogs in undefined order
    find_by_kind(:dog, :sorts => [[:name, :asc]], :limit => 10) # returns upto the first 10 dogs in alphebetical order of their name
    find_by_kind(:dog, :sorts => [[:name, :asc]], :limit => 10, :offset => 10) # returns the second set of 10 dogs in alphebetical order of their name

Filter operations and acceptable syntax:

    "=" "eq"
    "<" "lt"
    "<=" "lte"
    ">" "gt"
    ">=" "gte"
    "!=" "not"
    "contains?" "contains" "in?" "in"

Sort orders and acceptable syntax:

    :asc "asc" :ascending "ascending"
    :desc "desc" :descending "descending"

### Deleting a value:

    ; if you have a key...
    delete_by_key(my-key)

    ; otherwise
    delete_by_kind(:dog) ; deletes all records with :kind of "dog"
    delete_by_kind(:dog, :filters => [:name , "=", "Fido"]) ; deletes all dogs whos name is Fido
    delete_by_kind(:dog, :filters => [[:age, ">", 2], [:age, "<", 5]]) ; deletes all dogs between the age of 2 and 5 (exclusive)

### Entities

Used to define entities. An entity is simply an encapulation of data that is persisted.
The advantage of using entities are:

 * they limit the fields persisted to only what is specified in their definition
 * default values can be assigned to fields

Example:

    Hyperion.defentity(:citizen) do |kind|
      kind.field(:name)
      kind.field(:age)
      kind.field(:gender)
      kind.field(:country, default: 'USA')
      kind.field(:created_at) # populated automaticaly
      kind.field(:updated_at) # also populated automatically
    end
